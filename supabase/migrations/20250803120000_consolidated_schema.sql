-- EventPay: çµ±åˆã‚¹ã‚­ãƒ¼ãƒå®šç¾©
-- ç›®çš„: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å…¨ã¦ã®å‹ã€ãƒ†ãƒ¼ãƒ–ãƒ«ã€ãƒ“ãƒ¥ãƒ¼ã€RLSãƒãƒªã‚·ãƒ¼ã€é–¢æ•°ã‚’çµ±åˆå®šç¾©ã™ã‚‹ã€‚

-- ====================================================================
-- 1. ENUMå‹å®šç¾©
-- ====================================================================
CREATE TYPE public.event_status_enum AS ENUM ('upcoming', 'ongoing', 'past', 'cancelled');
CREATE TYPE public.payment_method_enum AS ENUM ('stripe', 'cash');
CREATE TYPE public.payment_status_enum AS ENUM ('pending', 'paid', 'failed', 'received', 'completed', 'refunded', 'waived');
CREATE TYPE public.attendance_status_enum AS ENUM ('attending', 'not_attending', 'maybe');
CREATE TYPE public.stripe_account_status_enum AS ENUM ('unverified', 'onboarding', 'verified', 'restricted');
CREATE TYPE public.payout_status_enum AS ENUM ('pending', 'processing', 'completed', 'failed');

COMMENT ON TYPE public.payment_status_enum IS 'æ±ºæ¸ˆçŠ¶æ³ (completedã¯ç„¡æ–™ã‚¤ãƒ™ãƒ³ãƒˆç”¨)';

-- ====================================================================
-- 2. ãƒ†ãƒ¼ãƒ–ãƒ«å®šç¾©
-- ====================================================================

-- users: é‹å–¶è€…æƒ…å ± (Supabase auth.usersã¨åŒæœŸ)
CREATE TABLE public.users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- events: ã‚¤ãƒ™ãƒ³ãƒˆæƒ…å ±
CREATE TABLE public.events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    created_by UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    date TIMESTAMP WITH TIME ZONE NOT NULL,
    location VARCHAR(500),
    fee INTEGER NOT NULL DEFAULT 0 CHECK (fee >= 0),
    capacity INTEGER CHECK (capacity IS NULL OR capacity > 0),
    description TEXT,
    registration_deadline TIMESTAMP WITH TIME ZONE,
    payment_deadline TIMESTAMP WITH TIME ZONE,
    payment_methods public.payment_method_enum[] NOT NULL CHECK (array_length(payment_methods, 1) > 0),
    invite_token VARCHAR(255) UNIQUE,
    status public.event_status_enum NOT NULL DEFAULT 'upcoming',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    CONSTRAINT events_date_after_creation CHECK (date > created_at),
    CONSTRAINT events_registration_deadline_before_event CHECK (registration_deadline IS NULL OR registration_deadline < date),
    CONSTRAINT events_payment_deadline_before_event CHECK (payment_deadline IS NULL OR payment_deadline < date),
    CONSTRAINT events_payment_deadline_after_registration CHECK (payment_deadline IS NULL OR registration_deadline IS NULL OR payment_deadline >= registration_deadline)
);
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;

-- attendances: ã‚¤ãƒ™ãƒ³ãƒˆã¸ã®å‡ºæ¬ æƒ…å ±
-- æ³¨æ„: guest_tokenã¯æ˜ç¤ºçš„ã«NOT NULLã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãªã—ï¼ˆã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å´ã§ç”Ÿæˆï¼‰
CREATE TABLE public.attendances (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id UUID NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    nickname VARCHAR(50) NOT NULL CHECK (LENGTH(TRIM(nickname)) >= 1),
    email VARCHAR(255) NOT NULL CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    status public.attendance_status_enum NOT NULL,
    guest_token VARCHAR(32) UNIQUE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);
ALTER TABLE public.attendances ENABLE ROW LEVEL SECURITY;
CREATE UNIQUE INDEX attendances_event_email_unique ON public.attendances(event_id, email);
COMMENT ON COLUMN public.attendances.guest_token IS 'Guest access token generated by application (Base64 format, 32 characters)';

-- payments: æ±ºæ¸ˆæƒ…å ±
-- æ³¨æ„: Stripeæ±ºæ¸ˆã§pendingçŠ¶æ…‹ã®å ´åˆã¯payment_intent_idãŒä¸è¦ã«ãªã‚‹ã‚ˆã†åˆ¶ç´„ã‚’ç·©å’Œ
CREATE TABLE public.payments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    attendance_id UUID NOT NULL UNIQUE REFERENCES public.attendances(id) ON DELETE CASCADE,
    method public.payment_method_enum NOT NULL,
    amount INTEGER NOT NULL CHECK (amount >= 0), -- 0å††ã‚’è¨±å®¹ (ç„¡æ–™ã‚¤ãƒ™ãƒ³ãƒˆç”¨)
    status public.payment_status_enum NOT NULL DEFAULT 'pending',
    stripe_payment_intent_id VARCHAR(255) UNIQUE,
    webhook_event_id VARCHAR(100), -- å†ªç­‰æ€§ç¢ºä¿ç”¨
    webhook_processed_at TIMESTAMP WITH TIME ZONE,
    paid_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    CONSTRAINT payments_stripe_intent_required CHECK (
        (method = 'stripe' AND status = 'pending') OR
        (method = 'stripe' AND status != 'pending' AND stripe_payment_intent_id IS NOT NULL) OR
        (method != 'stripe')
    ),
    CONSTRAINT payments_paid_at_when_completed CHECK ((status IN ('paid', 'received', 'completed') AND paid_at IS NOT NULL) OR (status NOT IN ('paid', 'received', 'completed')))
);
ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;

-- stripe_connect_accounts: Stripe Connectã‚¢ã‚«ã‚¦ãƒ³ãƒˆæƒ…å ±
CREATE TABLE public.stripe_connect_accounts (
    user_id UUID PRIMARY KEY REFERENCES public.users(id) ON DELETE CASCADE,
    stripe_account_id VARCHAR(255) UNIQUE NOT NULL,
    status public.stripe_account_status_enum NOT NULL DEFAULT 'unverified',
    charges_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    payouts_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);
ALTER TABLE public.stripe_connect_accounts ENABLE ROW LEVEL SECURITY;

-- payouts: é‹å–¶è€…ã¸ã®å£²ä¸Šé€é‡‘å±¥æ­´
CREATE TABLE public.payouts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id UUID NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    total_stripe_sales INTEGER NOT NULL DEFAULT 0,
    total_stripe_fee INTEGER NOT NULL DEFAULT 0, -- Stripeæ‰‹æ•°æ–™
    platform_fee INTEGER NOT NULL DEFAULT 0,
    net_payout_amount INTEGER NOT NULL DEFAULT 0,
    status public.payout_status_enum NOT NULL DEFAULT 'pending',
    stripe_transfer_id VARCHAR(255) UNIQUE,
    webhook_event_id VARCHAR(100), -- å†ªç­‰æ€§ç¢ºä¿ç”¨
    webhook_processed_at TIMESTAMP WITH TIME ZONE,
    processed_at TIMESTAMP WITH TIME ZONE,
    notes TEXT, -- ç®¡ç†ç”¨ãƒ¡ãƒ¢
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    CONSTRAINT payouts_amounts_non_negative CHECK (total_stripe_sales >= 0 AND total_stripe_fee >= 0 AND platform_fee >= 0 AND net_payout_amount >= 0),
    CONSTRAINT payouts_calculation_valid CHECK (net_payout_amount = total_stripe_sales - total_stripe_fee - platform_fee)
);
ALTER TABLE public.payouts ENABLE ROW LEVEL SECURITY;

-- invite_links: ã‚¤ãƒ™ãƒ³ãƒˆæ‹›å¾…ãƒªãƒ³ã‚¯
CREATE TABLE public.invite_links (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_id UUID NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
  token TEXT UNIQUE NOT NULL,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  max_uses INTEGER, -- NULL = ç„¡åˆ¶é™
  current_uses INTEGER DEFAULT 0,
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
ALTER TABLE public.invite_links ENABLE ROW LEVEL SECURITY;

-- ã‚·ã‚¹ãƒ†ãƒ ãƒ­ã‚°ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE IF NOT EXISTS public.system_logs (
    id BIGSERIAL PRIMARY KEY,
    operation_type VARCHAR(50) NOT NULL,
    details JSONB,
    executed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);
ALTER TABLE public.system_logs ENABLE ROW LEVEL SECURITY;

-- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ãƒ­ã‚°ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE IF NOT EXISTS public.security_audit_log (
    id BIGSERIAL PRIMARY KEY,
    event_type TEXT NOT NULL,
    user_role TEXT,
    ip_address INET,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
ALTER TABLE public.security_audit_log ENABLE ROW LEVEL SECURITY;

-- ====================================================================
-- 3. ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆ
-- ====================================================================
CREATE INDEX idx_events_created_by ON public.events(created_by);
CREATE INDEX idx_events_status ON public.events(status);
CREATE INDEX idx_attendances_event_id ON public.attendances(event_id);
CREATE INDEX idx_payments_status ON public.payments(status);
CREATE INDEX idx_payouts_user_id ON public.payouts(user_id);
CREATE INDEX idx_invite_links_token ON public.invite_links(token);

-- ====================================================================
-- 4. ãƒ“ãƒ¥ãƒ¼ã¨å®‰å…¨ãªé–¢æ•°
-- ====================================================================
-- public_profiles: å€‹äººæƒ…å ±ã‚’ä¿è­·ã—ã¤ã¤ã€å¿…è¦ãªæƒ…å ±ã®ã¿ã‚’å…¬é–‹ã™ã‚‹ãƒ“ãƒ¥ãƒ¼
CREATE OR REPLACE VIEW public.public_profiles AS SELECT id, name, created_at FROM public.users;
GRANT SELECT ON public.public_profiles TO authenticated, service_role;

-- get_event_creator_name: ã‚¤ãƒ™ãƒ³ãƒˆä½œæˆè€…åã‚’å®‰å…¨ã«å–å¾—ã™ã‚‹é–¢æ•°
CREATE OR REPLACE FUNCTION public.get_event_creator_name(p_creator_id UUID)
RETURNS TEXT LANGUAGE plpgsql SECURITY DEFINER STABLE AS $$
BEGIN
    RETURN (SELECT name FROM public.users WHERE id = p_creator_id);
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_event_creator_name(UUID) TO authenticated, service_role;

-- ====================================================================
-- 5. é–¢æ•°ã¨ãƒˆãƒªã‚¬ãƒ¼
-- ====================================================================
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN NEW.updated_at = NOW(); RETURN NEW; END;
$$;

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON public.users FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER update_events_updated_at BEFORE UPDATE ON public.events FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER update_attendances_updated_at BEFORE UPDATE ON public.attendances FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER update_payments_updated_at BEFORE UPDATE ON public.payments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER update_stripe_connect_accounts_updated_at BEFORE UPDATE ON public.stripe_connect_accounts FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER update_payouts_updated_at BEFORE UPDATE ON public.payouts FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER update_invite_links_updated_at BEFORE UPDATE ON public.invite_links FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE OR REPLACE FUNCTION public.check_attendance_capacity_limit()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
DECLARE event_capacity INTEGER; current_attending_count INTEGER;
BEGIN
    IF NEW.status = 'attending' THEN
        SELECT capacity INTO event_capacity FROM public.events WHERE id = NEW.event_id;
        IF event_capacity IS NOT NULL THEN
            SELECT COUNT(*) INTO current_attending_count FROM public.attendances WHERE event_id = NEW.event_id AND status = 'attending';
            IF current_attending_count >= event_capacity THEN RAISE EXCEPTION 'ã‚¤ãƒ™ãƒ³ãƒˆã®å®šå“¡ï¼ˆ%åï¼‰ã«é”ã—ã¦ã„ã¾ã™ã€‚', event_capacity; END IF;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;

CREATE TRIGGER check_attendance_capacity_before_insert_or_update
BEFORE INSERT OR UPDATE ON public.attendances FOR EACH ROW EXECUTE FUNCTION public.check_attendance_capacity_limit();

-- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«è‡ªå‹•ä½œæˆé–¢æ•°
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  -- auth.usersã‹ã‚‰ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¦public.usersã«ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
  INSERT INTO public.users (id, name)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', 'ãƒ¦ãƒ¼ã‚¶ãƒ¼')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ãƒˆãƒªã‚¬ãƒ¼ã®ä½œæˆ
-- auth.usersãƒ†ãƒ¼ãƒ–ãƒ«ã«ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒæŒ¿å…¥ã•ã‚ŒãŸå¾Œã€è‡ªå‹•çš„ã«public.usersã«ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
CREATE OR REPLACE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š
-- é–¢æ•°ã®å®Ÿè¡Œæ¨©é™ã‚’é©åˆ‡ã«è¨­å®šï¼ˆsupabase_auth_adminã®ã¿å®Ÿè¡Œå¯èƒ½ï¼‰
GRANT EXECUTE ON FUNCTION public.handle_new_user() TO supabase_auth_admin;
REVOKE EXECUTE ON FUNCTION public.handle_new_user() FROM authenticated, anon, public;

-- ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ ï¼ˆpublic.usersãƒ†ãƒ¼ãƒ–ãƒ«ã®é–¢æ•°ã®ã¿ï¼‰
COMMENT ON FUNCTION public.handle_new_user() IS
'auth.usersãƒ†ãƒ¼ãƒ–ãƒ«ã«æ–°ã—ã„ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä½œæˆã•ã‚ŒãŸéš›ã«ã€è‡ªå‹•çš„ã«public.usersãƒ†ãƒ¼ãƒ–ãƒ«ã«ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆã™ã‚‹é–¢æ•°';

-- ã‚²ã‚¹ãƒˆå‚åŠ çŠ¶æ³æ›´æ–°ã®ãŸã‚ã®ã‚¹ãƒˆã‚¢ãƒ‰ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£
CREATE OR REPLACE FUNCTION update_guest_attendance_with_payment(
  p_attendance_id UUID,
  p_status public.attendance_status_enum,
  p_payment_method public.payment_method_enum DEFAULT NULL,
  p_event_fee INTEGER DEFAULT 0
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_event_id UUID;
  v_payment_id UUID;
  v_current_status public.attendance_status_enum;
BEGIN
  -- å‚åŠ è¨˜éŒ²ã®å­˜åœ¨ç¢ºèªã¨ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å–å¾—
  SELECT event_id, status INTO v_event_id, v_current_status
  FROM attendances
  WHERE id = p_attendance_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Attendance record not found';
  END IF;

  -- å‚åŠ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°
  UPDATE attendances
  SET
    status = p_status,
    updated_at = NOW()
  WHERE id = p_attendance_id;

  -- æ±ºæ¸ˆãƒ¬ã‚³ãƒ¼ãƒ‰ã®å‡¦ç†
  IF p_status = 'attending' AND p_event_fee > 0 AND p_payment_method IS NOT NULL THEN
    -- æ—¢å­˜ã®æ±ºæ¸ˆãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ç¢ºèª
    SELECT id INTO v_payment_id
    FROM payments
    WHERE attendance_id = p_attendance_id;

    IF v_payment_id IS NOT NULL THEN
      -- æ—¢å­˜ã®æ±ºæ¸ˆãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°
      UPDATE payments
      SET
        method = p_payment_method,
        amount = p_event_fee,
        status = 'pending',
        updated_at = NOW()
      WHERE id = v_payment_id;
    ELSE
      -- æ–°ã—ã„æ±ºæ¸ˆãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆ
      INSERT INTO payments (
        attendance_id,
        amount,
        method,
        status,
        created_at,
        updated_at
      ) VALUES (
        p_attendance_id,
        p_event_fee,
        p_payment_method,
        'pending',
        NOW(),
        NOW()
      );
    END IF;
  ELSIF p_status != 'attending' THEN
    -- å‚åŠ ã—ãªã„å ´åˆã¯æ±ºæ¸ˆãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤
    DELETE FROM payments WHERE attendance_id = p_attendance_id;
  END IF;

  -- æˆåŠŸæ™‚ã¯ã‚³ãƒŸãƒƒãƒˆï¼ˆãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å†…ã§å®Ÿè¡Œã•ã‚Œã‚‹ï¼‰
  RETURN;
END;
$$;

-- å‚åŠ ç™»éŒ²ã®ãŸã‚ã®ã‚¹ãƒˆã‚¢ãƒ‰ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£
CREATE OR REPLACE FUNCTION public.register_attendance_with_payment(
  p_event_id UUID,
  p_nickname VARCHAR,
  p_email VARCHAR,
  p_status public.attendance_status_enum,
  p_guest_token VARCHAR,
  p_payment_method public.payment_method_enum DEFAULT NULL,
  p_event_fee INTEGER DEFAULT 0
)
RETURNS UUID -- æ–°ã—ãä½œæˆã•ã‚ŒãŸattendanceã®IDã‚’è¿”ã™
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_attendance_id UUID;
  v_event_exists BOOLEAN;
BEGIN
  -- å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ¤œè¨¼
  IF p_event_id IS NULL THEN
    RAISE EXCEPTION 'Event ID cannot be null';
  END IF;

  IF p_nickname IS NULL OR LENGTH(TRIM(p_nickname)) = 0 THEN
    RAISE EXCEPTION 'Nickname cannot be null or empty';
  END IF;

  IF p_email IS NULL OR LENGTH(TRIM(p_email)) = 0 THEN
    RAISE EXCEPTION 'Email cannot be null or empty';
  END IF;

  IF p_status IS NULL THEN
    RAISE EXCEPTION 'Status cannot be null';
  END IF;

  IF p_guest_token IS NULL OR LENGTH(p_guest_token) != 32 THEN
    RAISE EXCEPTION 'Guest token must be exactly 32 characters long, got: %', COALESCE(LENGTH(p_guest_token), 0);
  END IF;

  -- ã‚¤ãƒ™ãƒ³ãƒˆã®å­˜åœ¨ç¢ºèªã¨å®šå“¡ãƒã‚§ãƒƒã‚¯ï¼ˆæ’ä»–ãƒ­ãƒƒã‚¯ä»˜ãï¼‰
  SELECT EXISTS(SELECT 1 FROM public.events WHERE id = p_event_id FOR UPDATE) INTO v_event_exists;
  IF NOT v_event_exists THEN
    RAISE EXCEPTION 'Event with ID % does not exist', p_event_id;
  END IF;

  -- å®šå“¡ãƒã‚§ãƒƒã‚¯ï¼ˆattendingçŠ¶æ…‹ã®å ´åˆã®ã¿ï¼‰
  IF p_status = 'attending' THEN
    DECLARE
      v_capacity INTEGER;
      v_current_attendees INTEGER;
    BEGIN
      -- ã‚¤ãƒ™ãƒ³ãƒˆã®å®šå“¡ã‚’å–å¾—
      SELECT capacity INTO v_capacity FROM public.events WHERE id = p_event_id;

      -- å®šå“¡ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ãƒã‚§ãƒƒã‚¯
      IF v_capacity IS NOT NULL THEN
        -- ç¾åœ¨ã®å‚åŠ è€…æ•°ã‚’å–å¾—ï¼ˆæ’ä»–ãƒ­ãƒƒã‚¯ä»˜ãï¼‰
        SELECT COUNT(*) INTO v_current_attendees
        FROM public.attendances
        WHERE event_id = p_event_id AND status = 'attending'
        FOR UPDATE;

        -- å®šå“¡è¶…éãƒã‚§ãƒƒã‚¯
        IF v_current_attendees >= v_capacity THEN
          RAISE EXCEPTION 'Event capacity (%) has been reached. Current attendees: %', v_capacity, v_current_attendees;
        END IF;
      END IF;
    END;
  END IF;

  -- ã‚²ã‚¹ãƒˆãƒˆãƒ¼ã‚¯ãƒ³ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
  IF EXISTS(SELECT 1 FROM public.attendances WHERE guest_token = p_guest_token) THEN
    RAISE EXCEPTION 'Guest token already exists: %', LEFT(p_guest_token, 8) || '...';
  END IF;

  -- 1. attendancesãƒ†ãƒ¼ãƒ–ãƒ«ã«å‚åŠ è¨˜éŒ²ã‚’æŒ¿å…¥
  BEGIN
    INSERT INTO public.attendances (event_id, nickname, email, status, guest_token)
    VALUES (p_event_id, p_nickname, p_email, p_status, p_guest_token)
    RETURNING id INTO v_attendance_id;

    -- æŒ¿å…¥ãŒæˆåŠŸã—ãŸã‹ã‚’ç¢ºèª
    IF v_attendance_id IS NULL THEN
      RAISE EXCEPTION 'Failed to insert attendance record';
    END IF;

  EXCEPTION
    WHEN unique_violation THEN
      -- é‡è¤‡ã‚¨ãƒ©ãƒ¼ã®è©³ç´°ã‚’æä¾›
      IF SQLSTATE = '23505' AND CONSTRAINT_NAME = 'attendances_guest_token_key' THEN
        RAISE EXCEPTION 'Guest token already exists (unique constraint violation): %', LEFT(p_guest_token, 8) || '...';
      ELSE
        RAISE EXCEPTION 'Unique constraint violation: %', SQLERRM;
      END IF;
    WHEN OTHERS THEN
      RAISE EXCEPTION 'Failed to insert attendance: %', SQLERRM;
  END;

  -- 2. å‚åŠ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒ'attending'ã§ã€ã‚¤ãƒ™ãƒ³ãƒˆãŒæœ‰æ–™ã®å ´åˆã€paymentsãƒ†ãƒ¼ãƒ–ãƒ«ã«æ±ºæ¸ˆè¨˜éŒ²ã‚’æŒ¿å…¥
  IF p_status = 'attending' AND p_event_fee > 0 AND p_payment_method IS NOT NULL THEN
    BEGIN
      INSERT INTO public.payments (attendance_id, amount, method, status)
      VALUES (v_attendance_id, p_event_fee, p_payment_method, 'pending');
    EXCEPTION
      WHEN OTHERS THEN
        -- æ±ºæ¸ˆè¨˜éŒ²ã®æŒ¿å…¥ã«å¤±æ•—ã—ãŸå ´åˆã€å‚åŠ è¨˜éŒ²ã‚‚å‰Šé™¤ã—ã¦ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
        DELETE FROM public.attendances WHERE id = v_attendance_id;
        RAISE EXCEPTION 'Failed to insert payment record: %', SQLERRM;
    END;
  END IF;

  RETURN v_attendance_id;
END;
$$;

-- ãƒ†ã‚¹ãƒˆç”¨ãƒ†ãƒ¼ãƒ–ãƒ«ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–¢æ•° (é–‹ç™ºç’°å¢ƒå°‚ç”¨)
CREATE OR REPLACE FUNCTION public.cleanup_test_tables_dev_only()
RETURNS VOID LANGUAGE plpgsql SECURITY INVOKER AS $$
BEGIN
    -- è­¦å‘Š: ã“ã®é–¢æ•°ã¯é–‹ç™ºç’°å¢ƒå°‚ç”¨ã§ã™ã€‚æœ¬ç•ªç’°å¢ƒã§å®Ÿè¡Œã—ãªã„ã§ãã ã•ã„ã€‚
    RAISE WARNING 'Executing development-only cleanup function. This should not be run in production.';

    DELETE FROM public.payouts;
    DELETE FROM public.payments;
    DELETE FROM public.attendances;
    DELETE FROM public.invite_links;
    DELETE FROM public.events;
    DELETE FROM public.stripe_connect_accounts;
    DELETE FROM public.users;
    -- auth.usersã¯åˆ¥é€”ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã§ç®¡ç†
    RAISE NOTICE 'Test data cleanup completed for all public tables.';
END;
$$;
GRANT EXECUTE ON FUNCTION public.cleanup_test_tables_dev_only() TO service_role;

-- å­¤ç«‹ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œå‡ºé–¢æ•° (30æ—¥ä»¥ä¸Šæ´»å‹•ã®ãªã„ãƒ¦ãƒ¼ã‚¶ãƒ¼)
CREATE OR REPLACE FUNCTION public.detect_orphaned_users()
RETURNS TABLE(user_id UUID, email TEXT, days_since_creation INTEGER)
LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
    RETURN QUERY
    SELECT u.id, au.email, EXTRACT(DAYS FROM NOW() - u.created_at)::INTEGER
    FROM public.users u
    JOIN auth.users au ON u.id = au.id
    WHERE u.created_at < NOW() - INTERVAL '30 days'
      AND NOT EXISTS(SELECT 1 FROM public.events WHERE created_by = u.id);
END;
$$;
GRANT EXECUTE ON FUNCTION public.detect_orphaned_users() TO service_role;

-- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆè¨˜éŒ²é–¢æ•°
CREATE OR REPLACE FUNCTION public.log_security_event(p_event_type TEXT, p_details JSONB)
RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
    INSERT INTO public.security_audit_log (event_type, details, user_role, ip_address)
    VALUES (p_event_type, p_details, auth.role(), inet_client_addr());
EXCEPTION WHEN OTHERS THEN
    RAISE WARNING 'Failed to log security event: %', SQLERRM;
END;
$$;
GRANT EXECUTE ON FUNCTION public.log_security_event(TEXT, JSONB) TO authenticated, service_role;

-- ====================================================================
-- 6. Row Level Security (RLS) ãƒãƒªã‚·ãƒ¼
-- ====================================================================

-- users: è‡ªåˆ†ã®æƒ…å ±ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
CREATE POLICY "Users can view own profile" ON public.users FOR SELECT TO authenticated USING (auth.uid() = id);
CREATE POLICY "Users can update own profile" ON public.users FOR UPDATE TO authenticated USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
-- INSERT/DELETEã¯ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã‹ã‚‰ã®ã¿ (authãƒ•ãƒƒã‚¯çµŒç”±)

-- events: èª°ã§ã‚‚é–²è¦§å¯èƒ½ã€ä½œæˆè€…ã®ã¿ç®¡ç†å¯èƒ½
CREATE POLICY "Anyone can view events" ON public.events FOR SELECT TO anon, authenticated USING (true);
CREATE POLICY "Creators can manage own events" ON public.events FOR ALL TO authenticated USING (auth.uid() = created_by) WITH CHECK (auth.uid() = created_by);

-- attendances: é–¢ä¿‚è€…ã®ã¿é–²è¦§å¯èƒ½ã€æ›¸ãè¾¼ã¿ã¯ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã®ã¿
CREATE POLICY "Related parties can view attendances" ON public.attendances FOR SELECT TO authenticated USING (
    EXISTS (SELECT 1 FROM public.events WHERE id = attendances.event_id AND created_by = auth.uid())
);
-- Service role can manage attendances (Server Actionsç”¨)
CREATE POLICY "Service role can manage attendances"
ON public.attendances
FOR ALL
TO service_role
USING (true)
WITH CHECK (true);
-- ğŸš¨ INSERT/UPDATE/DELETEãƒãƒªã‚·ãƒ¼ã¯æ„å›³çš„ã«ä½œæˆã—ãªã„ (ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰APIçµŒç”±ã‚’å¼·åˆ¶)

-- payments: é–¢ä¿‚è€…ã®ã¿é–²è¦§å¯èƒ½ã€æ›¸ãè¾¼ã¿ã¯ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã®ã¿
CREATE POLICY "Creators can view payments" ON public.payments FOR SELECT TO authenticated USING (
    EXISTS (SELECT 1 FROM public.attendances a JOIN public.events e ON a.event_id = e.id WHERE a.id = payments.attendance_id AND e.created_by = auth.uid())
);
CREATE POLICY "Service role can manage payments" ON public.payments FOR ALL TO service_role USING (true) WITH CHECK (true);

-- stripe_connect_accounts & payouts: è‡ªåˆ† or service_roleã®ã¿ç®¡ç†å¯èƒ½
CREATE POLICY "Users can manage own stripe accounts" ON public.stripe_connect_accounts FOR ALL TO authenticated USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can view own payouts" ON public.payouts FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Service role can manage stripe/payout info" ON public.stripe_connect_accounts FOR ALL TO service_role USING (true) WITH CHECK (true);
CREATE POLICY "Service role can manage payouts" ON public.payouts FOR ALL TO service_role USING (true) WITH CHECK (true);

-- invite_links: ä½œæˆè€…ã®ã¿ç®¡ç†å¯èƒ½ã€èª°ã§ã‚‚æœ‰åŠ¹ãªãƒªãƒ³ã‚¯ã¯é–²è¦§å¯èƒ½
CREATE POLICY "Creators can manage invite links" ON public.invite_links FOR ALL TO authenticated
    USING (EXISTS (SELECT 1 FROM public.events WHERE id = invite_links.event_id AND created_by = auth.uid()))
    WITH CHECK (EXISTS (SELECT 1 FROM public.events WHERE id = invite_links.event_id AND created_by = auth.uid()));
CREATE POLICY "Anyone can view valid invite links" ON public.invite_links FOR SELECT TO anon, authenticated
    USING (expires_at > NOW() AND (max_uses IS NULL OR current_uses < max_uses));

-- ã‚·ã‚¹ãƒ†ãƒ ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°: service_roleã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
CREATE POLICY "Service role can access system logs" ON public.system_logs FOR ALL TO service_role USING (true);
CREATE POLICY "Service role can access security logs" ON public.security_audit_log FOR ALL TO service_role USING (true);

-- ====================================================================
-- 7. æ¨©é™è¨­å®š
-- ====================================================================
GRANT ALL ON public.system_logs TO service_role;
GRANT USAGE, SELECT ON SEQUENCE public.system_logs_id_seq TO service_role;
GRANT ALL ON public.security_audit_log TO service_role;
GRANT USAGE, SELECT ON SEQUENCE public.security_audit_log_id_seq TO service_role;

DO $$
BEGIN
    RAISE NOTICE 'âœ… Consolidated schema, RLS, and all functions created successfully.';
END $$;
