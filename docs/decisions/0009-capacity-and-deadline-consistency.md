# ADR-0009: 定員・締切の整合性保証（レースコンディション対策）

- **Status**: Accepted
- **Date**: 2025-12-21

## Context and Problem Statement

イベント管理システムにおいて、複数のユーザーが同時に参加登録を行う際、以下の問題が発生する可能性がある：

- **定員超過問題**: 定員1名のイベントに対して、2名以上が同時に登録リクエストを送信した場合、アプリケーションレベルのチェックだけでは定員を超過してしまう
- **締切後の登録**: 締切直前に複数のリクエストが到着した場合、締切時刻の判定タイミングによって整合性が損なわれる可能性
- **データ整合性**: 参加記録と決済記録の不整合、メールアドレスの重複登録など

## Decision Drivers

1. **データ整合性**: 定員を絶対に超過させない、データベースレベルでの保証が必要
2. **セキュリティ**: 不正な同時アクセスや定員回避の試みを検出・防止する必要
3. **パフォーマンス**: ロック機構による性能低下を最小限に抑える
4. **運用性**: システム監視とトラブルシューティングが容易であること
5. **ユーザー体験**: レースコンディション発生時も適切なエラーメッセージを返す

## Considered Options

### Option A: アプリケーションレベルでの楽観的ロック
- アプリケーション側で参加者数をカウントし、version番号で楽観的ロックを実装
- 競合発生時にリトライ処理を実行

### Option B: データベース排他ロック（FOR UPDATE）
- PostgreSQLの`FOR UPDATE`を使用して、イベントレコードに対する排他ロックを取得
- トランザクション内で定員チェックと参加登録を原子的に実行

### Option C: 分散ロック（Redis等）
- Redisなどの外部ストアで分散ロックを実装
- アプリケーション側で定員管理のロジックを制御

## Decision Outcome

**採用したオプション**: Option B（データベース排他ロック）

### 実装詳細

#### 1. 定員チェックの排他ロック実装

データベースストアドプロシージャ`register_attendance_with_payment`内で、`attending`ステータスの参加者登録時に以下を実装：
- イベントレコードに対して`FOR UPDATE`で排他ロックを取得
- ロック取得後、安全に参加者数をカウント
- 定員超過の場合は例外を発生させてトランザクションをロールバック

#### 2. 締切チェックの実装

参加登録前に`registration_deadline`をチェックし、締切を過ぎている場合は登録を拒否する。

#### 3. アプリケーション層での事前チェック

データベース層の最終チェックに加えて、アプリケーション層でも事前に定員チェックを実施し、早期エラー検出とユーザー体験の向上を実現。

#### 4. エラーハンドリングとセキュリティログ

レースコンディションが検出された場合、適切なエラーメッセージを返し、セキュリティログに記録する。

### 選択理由（Decision Driversとの対応）

1. **データ整合性**: データベースのACID特性により、定員超過が物理的に不可能
2. **セキュリティ**: すべての定員超過試行をログに記録し、監視可能
3. **パフォーマンス**: ロック取得は参加登録の短時間のみ。読み取り操作には影響なし
4. **運用性**: PostgreSQLの標準機能のため、特別な運用手順不要
5. **ユーザー体験**: 定員到達時に明確なエラーメッセージを表示

## Consequences

### Positive

1. **完全な定員保証**: データベースレベルでレースコンディションを完全に防止

2. **not_attending/maybeは定員に影響しない**: 参加ステータスに応じた適切な定員管理

3. **セキュリティ監査証跡**: すべての定員超過試行とレースコンディションを記録

4. **トランザクション保証**: 参加記録と決済記録の原子性を保証

### Negative

1. **書き込みロック競合**: 同時アクセスが多い場合、ロック待機が発生する可能性
   - 影響範囲: 参加登録のトランザクション時間（数百ミリ秒程度）のみ
   - 軽減策: 事前の定員チェックにより、満員イベントへの無駄なロック取得を回避

2. **データベース依存**: PostgreSQL固有の`FOR UPDATE`機能に依存
   - 軽減策: 標準的なSQLロック機構であり、移植性は比較的高い

## Pros and Cons of the Options

### Option A: アプリケーションレベルでの楽観的ロック

**Pros:**
- データベース非依存で実装可能
- 読み取り性能への影響が少ない

**Cons:**
- リトライロジックの複雑化
- 完全な定員保証が困難（タイミングによっては超過の可能性）
- アプリケーション層のバグにより整合性が崩れるリスク

### Option B: データベース排他ロック（採用）

**Pros:**
- データベースACID特性により完全な整合性保証
- 実装がシンプルで保守性が高い
- PostgreSQLの成熟した機能を活用

**Cons:**
- 同時書き込みが多い場合のロック競合
- 特定のデータベースに依存

### Option C: 分散ロック（Redis等）

**Pros:**
- 高性能な分散ロック実装が可能
- データベース負荷の分散

**Cons:**
- インフラの複雑化（Redisの運用が必要）
- ネットワーク障害時の挙動が複雑
- データベースとの二重管理によるバグリスク
