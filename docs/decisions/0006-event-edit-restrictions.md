# ADR-0006: イベント編集制限システム v2 - ルール駆動型の二層防御アーキテクチャ

- Status: Accepted
- Date: 2025-12-21

## Context and Problem Statement

イベント管理システムにおいて、参加者や決済の状況に応じて特定の項目を編集できないようにする必要がある。例えば、決済済みの参加者がいる場合に参加費を変更すると金銭トラブルが発生する可能性がある。

このような制限をアドホックに実装すると以下の問題が発生しうる：
- クライアント側（UI）とサーバ側（API）で制限ロジックが不一致になる
- 制限ルールの追加・変更時に複数箇所の修正が必要
- 制限理由がユーザーに明確に伝わらない
- テストが困難

## Decision Drivers

1. **セキュリティ**: クライアント側のバリデーションは回避可能なため、サーバ側での強制が必須
2. **一貫性**: クライアントとサーバで同じルールを適用し、齟齬を防ぐ
3. **保守性**: 制限ルールの追加・変更が容易であること
4. **ユーザー体験**: 制限理由を明確に伝え、入力前に制限を予防的に示す
5. **安全性**: エラー時は安全側（編集禁止）に倒す（フェイルクローズ）

## Considered Options

### Option A: クライアント・サーバ別々のバリデーション実装
従来の方法。各層で独自にバリデーションロジックを実装する。

### Option B: サーバ側のみで制限を実施
すべての制限チェックをサーバ側で行い、クライアントは制限を知らない。

### Option C: 統一ルールエンジンによる二層防御（採用）
共通のドメインロジック（`core/domain/event-edit-restrictions`）を定義し、クライアント・サーバ双方で同一エンジンを使用する。

## Decision Outcome

**Option C（統一ルールエンジンによる二層防御）を採用**

### 採用理由

- 一貫性の担保
- 三段階の制限レベル
   - `structural`: 絶対変更不可（例：決済済み参加者がいる場合の参加費）
   - `conditional`: 条件下で変更不可（例：参加者数未満への定員変更）
   - `advisory`: 変更可能だが警告（例：重要項目変更の注意喚起）
- フロントエンドでの予防的制御
- サーバ側での強制拒否
- フェイルクローズ設計

## Consequences

### Positive

- **セキュリティ向上**: API経由の直接攻撃でも制限を回避できない
- **保守性向上**: 制限ルールの追加は`rules.ts`への追加のみで完結
- **UX改善**: ユーザーは編集不可能なフィールドを事前に把握し、理由も理解できる
- **テスタビリティ**: ドメインロジックが独立しており、単体テストが容易
- **型安全性**: TypeScriptによる厳密な型定義

### Negative

- **初期実装コスト**: エンジン実装に一定の開発工数が必要
- **パフォーマンス考慮**: フォーム入力のたびに制限評価が発生（スロットリングで対応）
- **複雑性**: 制限ロジックとバリデーションロジックの境界が曖昧になる可能性

## Pros and Cons of the Options

### Option A: クライアント・サーバ別々の実装

**Pros:**
- 実装が単純
- 各層で最適化が可能

**Cons:**
- ロジックの重複
- 不一致のリスクが高い
- 保守コストが高い
- テストが煩雑

### Option B: サーバ側のみで制限

**Pros:**
- セキュリティは確保される
- 実装箇所が一箇所

**Cons:**
- UXが悪い（送信して初めてエラーがわかる）
- フィールド単位の制限表示ができない
- ネットワーク往復が必要

### Option C: 統一ルールエンジン（採用）

**Pros:**
- クライアント・サーバの一貫性
- 優れたUX（予防的な制限表示）
- 保守性とテスタビリティ
- 段階的な制限レベル
- フェイルクローズによる安全性

**Cons:**
- 初期実装コスト
- パフォーマンス考慮が必要
- ルール依存関係の管理が必要
